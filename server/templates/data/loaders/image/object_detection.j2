import json

class ObjectDetectionDataset(Dataset):
    def __init__(self, root, split='{{ split | default("train") }}', return_format='{{ return_format | default("dict") }}', label_type='file', label_map={{ label_map | default("None") }}, split_type='{{ split_type | default("include") }}'):
        self.root = Path(root) / split
        self.return_format = return_format
        self.transform = transforms.Compose([
            transforms.Resize((512, 512)),
            transforms.ToTensor()
        ])
        self.data = list((self.root / 'images').glob('*.jpg'))
        self.label_map = {{ label_map | default("self._infer_label_map()") }}

    def _infer_label_map(self):
        labels = set()
        for ann_path in (self.root / 'labels').glob('*.json'):
            anns = json.loads(ann_path.read_text())
            for obj in anns:
                labels.add(obj['label'])
        return {k: i for i, k in enumerate(sorted(labels))}

    def __len__(self):
        return len(self.data)

    def __getitem__(self, idx):
        img_path = self.data[idx]
        ann_path = Path(str(img_path).replace('images', 'labels').replace('.jpg', '.json'))
        anns = json.loads(ann_path.read_text())

        boxes = []
        labels = []
        for ann in anns:
            boxes.append(ann['bbox'])  # [x_min, y_min, width, height]
            labels.append(self.label_map[ann['label']])
        boxes = torch.tensor(boxes, dtype=torch.float32)
        labels = torch.tensor(labels, dtype=torch.int64)

        image = self.transform(Image.open(img_path).convert("RGB"))

        {% if self.return_format == 'tuple' %}
        return image, {'boxes': boxes, 'labels': labels}
        {% elif return_format == 'raw' %}
        return image
        {% else %}
        return {'image': image, 'boxes': boxes, 'labels': labels}
        {% endif %}

def get_loader(root, batch_size=4, split='train', shuffle=True, **kwargs):
    dataset = ObjectDetectionDataset(root=root, split=split, **kwargs)
    return DataLoader(dataset, batch_size=batch_size, shuffle=shuffle, collate_fn=lambda x: tuple(zip(*x)))
